#!/bin/bash
#
# Copyright 2016-2017 HLRS, University of Stuttgart
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

#=============================================================================
#
#         FILE: vsub
#
#        USAGE: vsub <parameters>
#
#  DESCRIPTION: The purpose of this wrapper is accept job submissions for
#               virtualized batch system environments.
#               Jobs are run in virtual machines instead of bare metal.
#
#      OPTIONS: ---
# REQUIREMENTS: Torque's job submission cli 'qsub' is installed and configured.
#               File const.sh is sourced before this file.
#         BUGS: ---
#        NOTES: ---
#       AUTHOR: Nico Struckmann, struckmann@hlrs.de
#      COMPANY: HLRS, University of Stuttgart
#      VERSION: 0.6
#      CREATED: Oct 02nd 2015
#     REVISION: May 12 2017
#
#    CHANGELOG
#         v0.2: Bug fixes
#         v0.3: Moved metadata generation to the prologue sequence
#         v0.4: Bug fixes and further refactoring
#         v0.5: New features added, bug fixes and more refactoring
#         v0.6: renamed from qsub to vsub
#
#=============================================================================

# time measurements
START=$(date +%s.%N);

#============================================================================#
#                                                                            #
#                          GLOBAL CONFIGURATION                              #
#                                                                            #
#============================================================================#

#
# Random uid to identify a job's corresponding files
#
if [ -z ${RUID-} ]; then
  RUID="$(echo $(date +%N) | sha256sum | cut -d ' ' -f1 | cut -c 1-15)";
fi

#
# load environment variables, config and common functions
#
source /etc/profile.d/99-mikelangelo-hpc_stack.sh;
source "$VTORQUE_DIR/common/const.sh" "$RUID" "$USER";
source "$VTORQUE_DIR/common/config.sh";
source "$VTORQUE_DIR/common/functions.sh";


#============================================================================#
#                                                                            #
#                          SCRIPT CONFIGURATION                              #
#                                                                            #
#============================================================================#


#
# RegExpr for validating of the resource values requested for VMs
# The list of regular expressions for valudating keys, defines at the same
# time all accepted 'vm key=value,..' parameters
#
declare -A REGEXPR=( \
                     [IMG]="^(/|\w|[0-9]|\.|_|-)+\.(img|qcow2)$"
                     [DISTRO]="^($SUPPORTED_OS)$" \
                     [RAM]="^[0-9]+(K|M|G|T)$" \
                     [VCPUS]="^[0-9]+$" \
                     [VMS_PER_NODE]="^[0-9]+$" \
                     [METADATA]="^(\w|[0-9]|.|_|-)+\.yaml$" \
                     [DISK]="^[0-9]+(K|M|G)$" \
                     [ARCH]="^(x86_64)$" \
                     [VCPU_PINNING]="^(disabled|Disabled|DISABLED|false|False|FALSE|no|No|NO|1|\
auto|enabled|Enabled|ENABLED|true|True|TRUE|yes|Yes|YES|0)$" \
                     [VM_PROLOGUE]="^(\w|[0-9]|.|_|-)+$" \
                     [VM_EPILOGUE]="^(\w|[0-9]|.|_|-)+$" \
                     [VRDMA]="^(enabled|true|yes|0|disabled|false|no|1)$" \
                     [UNCLOT]="^(enabled|true|yes|0|disabled|false|no|1)$" \
                     [UNCLOT_SHMEM]="^[0-9]+(K|M|G|T)$" \
                     [IOCM]="^(enabled|true|yes|0|disabled|false|no|1)$" \
                     [IOCM_MIN_CORES]="^[0-9]+$" \
                     [IOCM_MAX_CORES]="^[0-9]+$" \
                     [FS_TYPE]="^($FILESYSTEM_TYPE_RD|$FILESYSTEM_TYPE_SFS)$" \
                   );
                   #internal keys where no regex is needed for: METADATA_TEMPLATE

#
# Used to collect and to pass on the parsed VM parameters for the job
#
declare -A VM_PARAMETER=();

#
# Parameters that are cleaned off any vm resource requests
#
PARAMETERS_CLEANED="";

#
# Cached parameters that are passed on to Torque's qsub cmd
#
PARAMETERS_PBS_QSUB="";

#
# Last parameter in the resource request, if it is not a STDIN or
# Interactive job, it's the job script
#
LAST_PARAM="";

#
# Type of job to execute: batch, stdin, interactive
#
JOB_TYPE="";

#
# The (maybe modified) job script.
#
JOB_SCRIPT="";

#
# JobWrappers destination file name
# (same name as the original script is mandatory)
#
JOB_WRAPPER_FILENAME="";

#
# indicated vm job
#
VMJOB_REQ_DETECTED=false;

#
# indicates interactive job
#
IS_INTERACTIVE_JOB=false;

#
# indicates piped (STDIN) job
#
IS_READLINE_JOB=false;

#
# Indicates a batch job.
#
IS_BATCH_JOB=false;

#
# User pro/epilogue scripts (on bare metal host)
#
USER_PROLOGUE_SCRIPT="";
USER_EPILOGUE_SCRIPT="";

#
# User pro/epilogue scripts (in vm)
#
USER_VM_PROLOGUE_SCRIPT="";
USER_VM_EPILOGUE_SCRIPT="";

#
# Flag that indicates whether user want's not to submit job,
# but to generate files only, for manual execution
# corresponding vsub argument is '-gf'
#
DO_NOT_SUBMIT_JOB=false;

#
# PBS PPN resource request
#
PBS_RES_REQ_PPN="";

#
# Amount of RAM requested from PBS
#
PBS_RES_REQ_RAM="";

#
# Caches PBS resource requets cleaned off any -vm related parameters
#
CLEANED_PBS_RES_REQ="";

#
# print to stdout
#
PRINT_TO_STDOUT=true;


#============================================================================#
#                                                                            #
#                               FUNCTIONS                                    #
#                                                                            #
#============================================================================#


#---------------------------------------------------------
#
# $1: optional key
# $2: optional value, mandatory if $1 is given for debugging output
# $3: optional corresponding regExp
#
usage() {

  # we need a fake job file for the following
  touch /tmp/qsubfaketmpjob;
  # force qsub to print out its usage by using an invalid '-Ä' parameter
  $PBS_QSUB -Ä /tmp/qsubfaketmpjob 2>&1 | \
    grep -v 'invalid option' | \
    grep -v '\[exiting\]' | \
    sed 's,\[script\],\n    [[-gf] -vm <vm_parameters> [script]],';
  rm -f /tmp/qsubfaketmpjob;
  if $DEBUG \
      && [ $# -ge 2 ]; then
    logWarnMsg "Invalid value '$2' for key '$1' found, corresponding RegExpr is: '$3', skipping it.";
  fi
  exit 1;
}


#---------------------------------------------------------
#
# Prepares required dirs
#
prepare() {
  # create spool dir for the job
  mkdir -p $VM_JOB_DIR;
  if [ ! -d $VM_JOB_DIR ]; then
    logErrorMsg "Cannot create VM job dir '$VM_JOB_DIR'.";
  fi
}


#---------------------------------------------------------
#
# Ensures all required files, folders, etc is there.
# Aborts with error if not, since continuation would be
# causing errors anyways.
#
checkPreconditions() {

  logDebugMsg "Checking preconditions, whether everything is in place we depend on.";

  # check vm job dir
  if [ -z ${VM_JOB_DIR-} ]; then
    echo "ERROR: Directory 'VM_JOB_DIR' is not set!";
    exit 5;
  elif [ ! -d "$VM_JOB_DIR" ] \
      && $(! mkdir -p "$VM_JOB_DIR"); then
    echo "ERROR: Directory VM_JOB_DIR='$VM_JOB_DIR' does not exist!";
    exit 6;
  elif [ ! -w "$VM_JOB_DIR" ]; then
    echo "ERROR: Directory VM_JOB_DIR='$VM_JOB_DIR' is not writable!";
    exit 7;
  fi

  # is PBS qsub there and executable ?
  if [ ! -x $PBS_QSUB ]; then
    logErrorMsg "PBS qsub '$PBS_QSUB' does not exist or is not executable.";
  fi

  local templates="$SCRIPT_PROLOGUE_TEMPLATE \
$SCRIPT_PROLOGUE_PARALLEL_TEMPLATE \
$JOB_SCRIPT_WRAPPER_TEMPLATE";

  # check file permission, job will fail if not correct
  for fileName in $templates; do
    # check access rights for the templates
    if [ ! -r $fileName ]; then
      logErrorMsg "Cannot read template '$fileName', wrong permissions!";
    fi
  done

  logDebugMsg "Preconditions check passed successfully.";
}


#---------------------------------------------------------
#
# Parses a given vm param key=value pair and puts it in the
# global cache map that is used for the job's VM properties
#
# $1: key=value[,key=value]+
#
_putParameterInMap() {

  # check amount of params
  if [ $# -ne 1 ]; then
    logErrorMsg "Function '_putParameterInMap' called with '$#' arguments, '1' \
is expected.\nProvided params are: '$@'" 2;
  fi
  local parameterString=$1;
  local key;
  local value;
  # process key/value-pairs one-by-one
  for param in ${parameterString//,/ }; do

    # split up into key and value
    logTraceMsg "processing parameter '$param'.";
    key=$(echo $param | cut -d'=' -f1);
    value=$(echo $param | cut -d'=' -f2);
    if [ ! -n "$key" ] || [ ! -n "$value" ]; then
      logErrorMsg "Invalid or incomplete parameter string '$key=$value'.";
      usage $key $value;
    fi

    # convert the key to upper-case (for our cache map)
    key=$(echo $key | tr '[a-z]' '[A-Z]');

    # validate parsed key/value
    logTraceMsg "validating parameter set key='$key', value='$value'";
    if [ -z "$key" ]; then
      #empty $key
      # stop here, nothing to parse
      break;
    fi
    
    if [ ! -n "${REGEXPR[$key]-}" ]; then
      logErrorMsg "No RegExpr found for key '$key'!" 2;
    elif [[ $value =~ ${REGEXPR[$key]} ]]; then
      logTraceMsg "Valid key=value pair found.";
      logTraceMsg "key: '$key', value: '$value'";
      # set the flag in case it's not set yet
      VMJOB_REQ_DETECTED=true;
      # command line parameter overwrite inline ones
      # resolve relative path for files
      if [ $key == "VM_PROLOGUE" ] \
         || [ $key == "VM_EPILOGUE" ]; then
        # ensure we do not have a relative path
        value="$(realpath $value)";
        # check if file exists, if not abort
        if [ ! -f "$value" ]; then
          logErrorMsg "The given argument '$key' is not a valid file '$value' !";
        fi
      # is it RAM ?
      elif [ "$key" == "RAM" ]; then
        value=$(_convertRAMtoMB $value);
      # is it UNCLOT IVSHMEM ?
      elif [ "$key" == "UNCLOT_SHMEM" ]; then
        value=$(_convertRAMtoMB $value);
      # is it a boolean, e.g. UNCLOT or VRDMA or IOCM ?
      elif [[ "$key" =~ ^(UNCLOT|VRDMA|IOCM)$ ]]; then
        # convert string to boolean
        if [[ "$value" =~ ^(disabled|Disabled|DISABLED|false|False|FALSE|no|No|NO|1)$ ]]; then
          value='false';
        elif [[ "$value" =~ ^(auto|enabled|Enabled|ENABLED|true|True|TRUE|yes|Yes|YES|0)$ ]]; then
          value='true';
        else
          logErrorMsg "Invalid value for argument '-vm $key=<value>' provided, boolean expected.";
        fi
      elif [ $key == "VCPU_PINNING" ]; then
        # check if it is a boolean or a mapping file
        if [[ "$value" =~ ^(disabled|Disabled|DISABLED|false|False|FALSE|no|No|NO|1)$ ]]; then
          value='false';
        elif [[ "$value" =~ ^(auto|enabled|Enabled|ENABLED|true|True|TRUE|yes|Yes|YES|0)$ ]]; then
          value='true';
        else
          # ensure we do not have a relative path
          local mappingFile="$(realpath $value)";
          if [ ! -f "$mappingFile" ]; then
            logErrorMsg "VCPU mapping file is not a valid file: '$mappingFile'.";
          fi
          # cache it
          VM_PARAMETER[$key]="$mappingFile";
        fi
      elif [ $key == "IMG" ]; then
        # user provided images are allowed ?
        if ! $ALLOW_USER_IMAGES; then
          logDebugMsg "User images not allowed, searching for the filename '$value' in global img pool dir '$VM_IMG_DIR'.";
          value="$VM_IMG_DIR/$(basename $value)";
        elif [ ! -e "$value" ]; then
          # assume the filename is provided, only
          # check pwd first
          value="$(pwd)/$(basename $value)";
        fi
        if [ ! -e "$value" ]; then
          # assume the filename is provided, only
          # check VM_IMG_DIR as next
          value="$VM_IMG_DIR/$(basename $value)";
        fi
        # found ?
        if [ ! -e "$value" ]; then
          # seems not to be an absolute path (assuming file exists), search for it in the VM_IMG_DIR
          logErrorMsg "There is no image file named '$value' in global image dir '$VM_IMG_DIR'.";
        fi
      else # no special argument, just cache it
        # copy as it is
        VM_PARAMETER[$key]=$value;
      fi
      # put into map
      logTraceMsg "putting \"key='$key' => value='$value'\" into VM_PARAMETER map.";
      VM_PARAMETER["$key"]=$value;
    else
      # invalid key/value
      logDebugMsg "Invalid value='$value' for key='$key' => found REGEXPR is '${REGEXPR[$key]}'.";
      usage $key $value ${REGEXPR[$key]};
    fi
  done
}


#---------------------------------------------------------
#
# Set the metadata template in the global cache map
# for the job's VM that strongly depends on the guest OS
#
setMetadataTemplate() {

  local noDistroFlag;

  # distro given ?
  if [ -n "${VM_PARAMETER['DISTRO']}" ]; then
    # determine based on given distro
    if [[ "${VM_PARAMETER['DISTRO']}" =~ $REGEX_DEBIAN ]]; then
      VM_PARAMETER["METADATA_TEMPLATE"]=$METADATA_TEMPLATE_DEBIAN;
    elif [[ "${VM_PARAMETER['DISTRO']}" =~ $REGEX_REDHAT ]]; then
      VM_PARAMETER["METADATA_TEMPLATE"]=$METADATA_TEMPLATE_REDHAT;
    elif [[ "${VM_PARAMETER['DISTRO']}" =~ $REGEX_OSV ]]; then
      VM_PARAMETER["METADATA_TEMPLATE"]=$METADATA_TEMPLATE_OSV;
    else
      logErrorMsg "Parameter 'distro' is invalid: '${VM_PARAMETER['IMG']-}', supported OS distros are: $SUPPORTED_OS";
    fi
    noDistroFlag=false;
  else
    noDistroFlag=true;
    logWarnMsg "Parameter 'distro' not provided, trying to determine it based on the image name";
  fi

  # image given ?
  if [ -n "${VM_PARAMETER['IMG']}" ]; then
    # determine based on given image name
    if [[ ${VM_PARAMETER["IMG"]} =~ $REGEX_DEBIAN ]]; then
      VM_PARAMETER["METADATA_TEMPLATE"]=$METADATA_TEMPLATE_DEBIAN;
      VM_PARAMETER["DISTRO"]="debian";
    elif [[ ${VM_PARAMETER["IMG"]} =~ $REGEX_REDHAT ]]; then
      VM_PARAMETER["METADATA_TEMPLATE"]=$METADATA_TEMPLATE_REDHAT;
      VM_PARAMETER["DISTRO"]="debian";
    elif [[ ${VM_PARAMETER["IMG"]} =~ $REGEX_OSV ]]; then
      VM_PARAMETER["METADATA_TEMPLATE"]=$METADATA_TEMPLATE_OSV;
      VM_PARAMETER["DISTRO"]="osv";
    elif $noDistroFlag; then
      logErrorMsg "Cannot determine OS, parameter 'distro=' is not provided.";
      logErrorMsg "Unknown OS image given: '${VM_PARAMETER['IMG']-}', supported are: $SUPPORTED_OS";
    fi
  elif $noDistroFlag; then
    logErrorMsg "Neither 'distro' is given, not it can be resolved from the image's name '${VM_PARAMETER['IMG']-}'\n\
Please make sure the image name contains the os name, i.e. 'debian'.";
  fi
}


#---------------------------------------------------------
#
# Parses user provided metadata based on a white list of
# allow keys that are accepted
#
parseUserMetadata() {

  # debug log
  logDebugMsg "Parse user metadata, key: 'METADATA' ";

  # is there any metadata provided ?
  if [ -z ${VM_PARAMETER["METADATA"]-} ]; then # no
    logDebugMsg "No User metadata provided".
    VM_PARAMETER["METADATA"]="";
    return 0;
  fi

  # is it a file ?
  if [ ! -f ${VM_PARAMETER["METADATA"]} ] \
       || [ ! -r ${VM_PARAMETER["METADATA"]} ]; then
    # error, not a readable file
    logErrorMsg "Metadata file '${VM_PARAMETER[METADATA]}' cannot be read !";
  fi

  # file we are going to built
  local userMetadataFile="$VM_JOB_DIR/metadata-user.yaml";

  # TODO parse and validate
  VM_PARAMETER["METADATA"]="";
  return 0;

  # replace the file cached
  VM_PARAMETER["METADATA"]=$userMetadataFile;
}


#---------------------------------------------------------
#
# Appends arg to cached cleaned PBS parameters list.
#
_appendCleanedPBSparams() {
  local arg=$1;
  if [ $# -eq 1 ] && [ -n "$arg" ]; then
    if [ -n "$PARAMETERS_CLEANED" ]; then
      PARAMETERS_CLEANED="$PARAMETERS_CLEANED $arg";
    else
      PARAMETERS_CLEANED="$arg";
    fi
  fi
  logTraceMsg "Cleaned PBS params: '$PARAMETERS_CLEANED'";
}


#---------------------------------------------------------
#
# Parses all '-vm' related parameters in args provided by user
# at submission time.
# Parsed -vm parameters are cached in a map, while the cleaned,
# PBS only arguments are cached as string in global var
# $PARAMETERS_CLEANED
#
_parseVMparameters() {

  # cache parameters
  local params=$@;

  local key;
  local value;
  local arg;
  local tmpResReq;
  
  # init loop var
  local next="";
  
  # clear global cache var
  PARAMETERS_CLEANED="";

  #
  # parse command line (vm) parameters
  #
  logTraceMsg "Parsing parameters: '${params[@]}'";
  for arg in $params; do
    logTraceMsg "Parsing '$arg'";
    # pbs key/value params like '-l nodes=3', '-q batch', ..
    if [[ "$arg" =~ ^-($PBS_KV_PARAMETERS)$ ]]; then
      logTraceMsg "Parsed key indicates next is a PBS key/value pair: '$arg'";
      next="PBS_ARG_VALUE";
      key="$arg";
      _appendCleanedPBSparams "$arg";
    # pbs flag params that have no value
    elif [[ "$arg" =~ ^-($PBS_FLAG_PARAMETERS)$ ]]; then
      logTraceMsg "Assuming PBS resource request flag, caching it: '$arg'";
      _appendCleanedPBSparams "$arg";
      next="";
      key="$arg";
    # previously we parsed a key, so this is keys value
    elif [ "$next" == "PBS_ARG_VALUE" ]; then
      # check if value starts with '-' that would indicate a key
      if [[ "$next" =~ ^-\w ]]; then
        logDebugMsg "Previously parsed key indicated next is a PBS key/value pair, but we found: '$arg'";
        usage "$key" "$arg" "$next";
      fi
      logTraceMsg "Assuming PBS key/value resource request, caching it: '$arg'";
      _appendCleanedPBSparams "$arg";
      # check if the value we have is the core count per node (PPN)
      if [[ "$arg" =~ \:(ppn|mem)\= ]]; then
        logTraceMsg "PBS key/value resource request (with i.e. ':ppn=') detected ";
        tmpResReq=":";
        # cache it in a separate var
        for resReq in ${arg//:/ }; do
          if [ $tmpResReq == ":" ]; then
            tmpResReq="$resReq";
          elif [[ "$resReq" =~ ^ppn\= ]]; then
            PBS_RES_REQ_PPN=$(echo $resReq | cut -d'=' -f2 | cut -d',' -f1 | cut -d'+' -f1);
            tmpResReq="$tmpResReq:ppn=PLACEHOLDER_PPN";
          elif [[ "$resReq" =~ ^mem\= ]]; then
            PBS_RES_REQ_RAM=$(echo $resReq | cut -d'=' -f2 | cut -d',' -f1 | cut -d'+' -f1);
            tmpResReq="$tmpResReq:mem=PLACEHOLDER_RAM";
          else
            tmpResReq="$tmpResReq:$resReq";
          fi
        done
        if ! [[ "$tmpResReq" =~ ":" ]]; then
          CLEANED_PBS_RES_REQ="$tmpResReq,";
          logTraceMsg "Appending cached arguments: 'CLEANED_PBS_RES_REQ=\"$tmpResReq,\"'";
        fi
      fi
      next="";
    # vm key/value params
    elif [ "$arg" == "-vm" ]; then
      logTraceMsg "Parsed key indicates next is a VM key/value pair: '$arg'";
      next="VM_ARG_VALUE";
      key="$arg";
    # vm key/value params
    elif [ "$next" == "VM_ARG_VALUE" ]; then
      # check if value starts with '-' which would indicate a key instead
      if [[ "$next" =~ ^-\w ]]; then
        logDebugMsg "Previously parsed key indicates next is a VM key/value pair, but we found: '$arg'";
        usage "$key" "$arg" "$next";
      fi
      logTraceMsg "VM resource request detected, 'key=value[,key=value]*' pair(s): '$arg'";
      # '-vm' arg is expected to be a 'key=value' pair
      _putParameterInMap "$arg";
      next="";
    elif [ "$arg" == "-gf" ]; then
      if ${ENABLE_DEV_MODE-false}; then
        logDebugMsg "Detected flag '-gf' to generate files, only.";
        # generate files for manual debugging, only
        DO_NOT_SUBMIT_JOB=true;
      else
        logErrorMsg "Argument '-gf' is allowed in development mode, only!";
      fi
    else # neither a defined PBS key[/value], not a vm key
      # we assume it's the last one, the optional job script file
      # compare the current match to the last parameter provided
      if [ "${params##* }" != "$arg" ]; then
        logDebugMsg "We found a parameter that is neither a PBS/vm parameter\
,nor it is the last one!\n Argument found: '$arg'\n Parameter String: '$params'";
        usage;
      fi
      LAST_PARAM="$arg"; #"${arg#*=}"; # when we leave the loop, last one is cached
      logTraceMsg "Assuming PBS resource request, caching it: '$arg'";
      next="";
    fi
  done

  logDebugMsg "Last Parameter, if present is expected to be the script job file: '$LAST_PARAM'";
  return 0;
}


#
# Parses inline '#PBS -vm <...> resource requests
#
_parseInlineResRequests() {

  # ensure there is a valid batch job file
  if [ ! -f $LAST_PARAM ]; then
    logWarnMsg "Last parameter is not a valid file: '$LAST_PARAM'";
    usage;
  fi

  local line;
  local tmpParamStr;
  local keyValuePair;

  #
  # check if '-vm <key=value,key=value,...>' is being requested in the file
  #
  if [ -n "$(cat $LAST_PARAM | grep -E '^#PBS\ +-vm\ ')" ] ; then
    # set global flag that indicates VM jobs
    VMJOB_REQ_DETECTED=true;
    # create a tmp script into that we pipe the cleaned content
    # so we remove '#PBS -vm ..' matches, but keep the '#PBS -l ..'
    mkdir -p $(dirname $TMP_JOB_SCRIPT);
    # check if there are inline #PBS arguments
    while read -r line; do
      if [[ "$line" =~ ^\#PBS\ +-vm\ + ]] ; then #yes
        logTraceMsg "Found in-line '#PBS ..' resource request:\n line: '$line'";
        # parse the part behind '^\#PBS\ +-vm\ +' and validate it
        tmpParamStr=(${$(echo $line | tr -s ' ' | cut -d' ' -f3)//,/ })
        for keyValuePair in $tmpParamStr; do
          # put parameters in the map
          _putParameterInMap $keyValuePair;
        done
      elif  [[ "$line" =~ ^\#PBS\  ]]; then
        # remove the found '#PBS -vm ..' to not confuse Torque
        echo $line >> $JOB_WRAPPER_RES_REQUEST_FILE;
      else
        # write all other lines that do not contain any '^#PBS '
        # into the actual job script to be executed inside the VMs
        echo $line >> $TMP_JOB_SCRIPT;
      fi
    done < $LAST_PARAM;
  fi
}


#
# Parses '-vm <key/value>' parameters from STDIN
#
_parsePipedResRequests() {

  #
  # check the input stream
  #

  if [ -z ${TMP_JOB_SCRIPT-} ]; then
    logErrorMsg "Fatal Error: 'TMP_JOB_SCRIPT' is not set!";
  fi
  logDebugMsg "Last Parameter is not a valid file. We will read the STDIN \
until there's an 'EOF'.\nPress 'ctrl+c' if this is not what you want";

  # create a file where we store the piped contents
  logDebugMsg "Creating tmp job script file '$TMP_JOB_SCRIPT'";
  mkdir -p $(dirname $TMP_JOB_SCRIPT);

  local line;
  local tmpParamStr;
  local keyValuePair;

  # input stream contains '#PBS -vm <key=value>' ??
  while read line; do
    if [[ "$line" =~ ^\#PBS\ +-vm\ + ]] ; then #yes
      VMJOB_REQ_DETECTED=true;
      logTraceMsg "Found in-line '#PBS ..' resource request:\n line: '$line'";
      # parse the part behind '^\#PBS\ +-vm\ +' and validate it
      tmpParamStr=(${$(echo $line | tr -s ' ' | cut -d' ' -f3)//,/ })
      for keyValuePair in $tmpParamStr; do
        # put parameters in the map
        _putParameterInMap $keyValuePair;
      done
    elif  [[ "$line" =~ ^\#PBS\  ]]; then
      # remove the found '#PBS -vm ..' to not confuse Torque
      echo $line >> $JOB_WRAPPER_RES_REQUEST_FILE;
    else
      # write all other lines that do not contain any '^#PBS ' into the
      # actual job script to be executed inside the VMs
      echo $line >> $TMP_JOB_SCRIPT;
    fi
  done
  # trace log
  logTraceMsg "Tmp file contents:\n-----\n$(cat $TMP_JOB_SCRIPT)\n----";
}


#---------------------------------------------------------
#
# Converts given amount of RAM requested for each VM
# to MB.
#
_convertRAMtoMB() {

  # convert all to uppercase
  arg=$(echo $1 | tr '[:upper:]' '[:lower:]');

  if [[ "$arg" =~ K$ ]]; then
    arg=$(echo $arg | cut -d'K' -f1);
    arg=$(($arg * 1024));
  elif [[ "$arg" =~ M$ ]]; then
    arg=$(echo $arg | cut -d'M' -f1);
  elif [[ "$arg" =~ G$ ]]; then
    arg=$(echo $arg | cut -d'G' -f1);
    arg=$(($arg / 1024));
  else
    logErrorMsg "Invalid value for RAM: '$arg' !";
  fi

  echo $arg;
}


#---------------------------------------------------------
#
# Detects kind of jobs (batch, stdin, interactive) and further
# checks whether the resource request contains virtual resources.
# at the end of the function the inline resource requests are evaluated
# that override any inline ones
#
parseParameter() {

  # cache parameters
  declare -a params=$@;
  local aliasStr;

  if [ ${#params[@]} -gt 0 ]; then
    # check if there is an alias included
    for i in ${!params[@]}; do
      aliasStr="${params[i]}";
      if [ -n "$aliasStr" ] && [ -n "${ALIAS_MAP[$aliasStr]-}" ]; then
        params[i]="${ALIAS_MAP[$aliasStr]}";
        logDebugMsg "Alias found: '$aliasStr', replacing it with '${params[i]}'.";
      fi
    done
  fi
  # is it an interactive job ?
  if [[ "${params[@]}" =~ -I$|-I\ + ]]; then

    # interactive job request detected
    logDebugMsg "Interactive Job request detected.";

    # set the global var to true
    IS_INTERACTIVE_JOB=true;
  elif [[ -p /dev/stdout ]]; then
    # piped content
    IS_READLINE_JOB=true;
  else
    IS_BATCH_JOB=true;
    # job script
  fi

  if [[ "${params[@]}" =~ -vm\  ]]; then # yes
    VMJOB_REQUESTED=true;
    logDebugMsg "Found '-vm' parsing cmd line arguments for VM resource requests.";
    _parseVMparameters $params;
  fi

  #
  # do not care about interactive in part below,
  # since we want to enable Torque to accept that, too
  #

  # last parameter is a valid file ?
  if [ -f "$LAST_PARAM" ]; then
    logDebugMsg "Checking file '$LAST_PARAM' for inline '#PBS -vm key=value' in file '$LAST_PARAM'.";
    # check job script for -vm parameters
    _parseInlineResRequests;
  elif $IS_READLINE_JOB; then
    logDebugMsg "Checking file 'STDIN' for inline '#PBS -vm key=value' in STDIN";
    _parsePipedResRequests;
  fi
}


#---------------------------------------------------------
#
# Sets for all missing VM properties the default values in
# the global cache map
#
applyVMDefaultParameter() {

  # do we handle a -vm request at all ?
  if ! $VMJOB_REQUESTED; then
    return 0;
  fi

  # debugging ?
  if [ -z ${VM_PARAMETER['DEBUG']-} ]; then
    logTraceMsg "Applying DEBUG='$DEBUG' as default VM parameter.";
    VM_PARAMETER['DEBUG']="$DEBUG";
  fi

  # trace ?
  if [ -z ${VM_PARAMETER['TRACE']-} ]; then
    logTraceMsg "Applying TRACE='$TRACE' as default VM parameter.";
    VM_PARAMETER['TRACE']="$TRACE";
  fi

  # file-system to use
  if [ -z ${VM_PARAMETER['FILESYSTEM_TYPE']-} ]; then
    logTraceMsg "Applying FILESYSTEM_TYPE='$FILESYSTEM_TYPE_DEFAULT' as default VM parameter.";
    VM_PARAMETER['FILESYSTEM_TYPE']="$FILESYSTEM_TYPE_DEFAULT";
  fi

  # vcpu pinning
  if [ -z ${VM_PARAMETER['VCPU_PINNING']-} ]; then
    logTraceMsg "Applying VCPU_PINNING='$VCPU_PINNING_DEFAULT' as default VM parameter.";
    VM_PARAMETER['VCPU_PINNING']="$VCPU_PINNING_DEFAULT";
  fi

  # amount of vcpus
  if [ -z ${VM_PARAMETER['VCPUS']-} ]; then
    logTraceMsg "Applying VCPUS='$VCPUS_DEFAULT' as default VM parameter.";
    VM_PARAMETER['VCPUS']="$VCPUS_DEFAULT";
  fi

  # vms per node
  if [ -z ${VM_PARAMETER['VMS_PER_NODE']-} ]; then
    logTraceMsg "Applying VMS_PER_NODE='$VMS_PER_NODE_DEFAULT' as default VM parameter.";
    VM_PARAMETER['VMS_PER_NODE']="$VMS_PER_NODE_DEFAULT";
  fi

  # amount of RAM
  if [ -z ${VM_PARAMETER['RAM']-} ]; then
    logTraceMsg "Applying RAM='$RAM_DEFAULT' as default VM parameter.";
    VM_PARAMETER['RAM']="$RAM_DEFAULT";
  fi

  # VM image
  if [ -z ${VM_PARAMETER['IMG']-} ]; then
    logTraceMsg "Applying IMG='$IMG_DEFAULT' as default VM parameter.";
    VM_PARAMETER['IMG']="$VM_IMG_DIR/$IMG_DEFAULT";
    logTraceMsg "Applying DISTRO='$DISTRO_DEFAULT' as default VM parameter.";
    VM_PARAMETER['DISTRO']="$DISTRO_DEFAULT";
  fi

  # distro
  if [ -z ${VM_PARAMETER['DISTRO']-} ]; then
    # no distro given, check the image name
    if [[ ${VM_PARAMETER['IMG']} =~ $SUPPORTED_OS ]]; then
      VM_PARAMETER['DISTRO']=$(echo ${VM_PARAMETER['IMG']} | grep -oi -E $SUPPORTED_OS);
    else
      logWarnMsg "No distro info about guest OS for custom image provided! Supported distros are: '$SUPPORTED_OS'";
      usage;
    fi
  fi

  # optional persistent disk (mount on rank0)
  if [ -z ${VM_PARAMETER['DISK']-} ]; then
    logTraceMsg "Applying DISK='$DISK_DEFAULT' as default VM parameter.";
    VM_PARAMETER['DISK']="$DISK_DEFAULT";
  fi

  # arch for the VM
  if [ -z ${VM_PARAMETER['ARCH']-} ]; then
    logTraceMsg "Applying ARCH='$ARCH_DEFAULT' as default VM parameter.";
    VM_PARAMETER['ARCH']="$ARCH_DEFAULT";
  fi

  # enable ioCM
  if [ -z ${VM_PARAMETER['IOCM']-} ]; then
    logTraceMsg "Applying IOCM='$IOCM_ENABLED_DEFAULT' as default VM parameter.";
    VM_PARAMETER['IOCM']=$IOCM_ENABLED_DEFAULT;
  fi

  # min amount of ioCM cores
  if [ -z ${VM_PARAMETER['IOCM_MIN_CORES']-} ]; then
    logTraceMsg "Applying IOCM_MIN_CORES='$IOCM_MIN_CORES_DEFAULT' as default VM parameter.";
    VM_PARAMETER['IOCM_MIN_CORES']="$IOCM_MIN_CORES_DEFAULT";
  fi

  # max amount of ioCM cores
  if [ -z ${VM_PARAMETER['IOCM_MAX_CORES']-} ]; then
    logTraceMsg "Applying IOCM_MAX_CORES='$IOCM_MAX_CORES_DEFAULT' as default VM parameter.";
    VM_PARAMETER['IOCM_MAX_CORES']="$IOCM_MAX_CORES_DEFAULT";
  fi

  # use vRDMA
  if [ -z ${VM_PARAMETER['VRDMA']-} ]; then
    logDebugMsg "Applying VRDMA='$VRDMA_ENABLED_DEFAULT' as default VM parameter.";
    VM_PARAMETER['VRDMA']=$VRDMA_ENABLED_DEFAULT;
  fi

  # use UNCLOT
  if [ -z ${VM_PARAMETER['UNCLOT']-} ]; then
    # UNCLOT for OSv, only, not SLG
    if [[ ${VM_PARAMETER[DISTRO]-} =~ $REGEX_OSV ]]; then
      logDebugMsg "Applying UNCLOT='$UNCLOT_ENABLED_DEFAULT' as default VM parameter.";
      VM_PARAMETER['UNCLOT']=$UNCLOT_ENABLED_DEFAULT;
    else # UNCLOt not available
      logDebugMsg "Applying UNCLOT='false' as default VM parameter, guest is not OSv.";
      VM_PARAMETER['UNCLOT']=$UNCLOT_ENABLED_DEFAULT;
    fi
  # UNCLOT only for OSv, not SLG
  elif ${VM_PARAMETER[UNCLOT]} \
      && [[ ! ${VM_PARAMETER[DISTRO]-} =~ $REGEX_OSV ]]; then
    logWarnMsg "UNCLOT is available for OSv guests, only. Will be disabled.";
    VM_PARAMETER[UNCLOT]=false;
  fi

  # use UNCLOT SHMEM
  if ${VM_PARAMETER[UNCLOT]} \
      && [ -z ${VM_PARAMETER['UNCLOT_SHMEM']-} ]; then
    logDebugMsg "Applying UNCLOT_SHMEM='$UNCLOT_SHMEM_DEFAULT' as default VM parameter.";
    VM_PARAMETER['UNCLOT_SHMEM']=$UNCLOT_SHMEM_DEFAULT;
  fi

  # global admin setting override user settings
  if ! $IOCM_ENABLED; then
    VM_PARAMETER['IOCM']=false;
    VM_PARAMETER['IOCM_MIN_CORES']="";
    VM_PARAMETER['IOCM_MAX_CORES']="";
  fi

  if ! $VRDMA_ENABLED; then
    VM_PARAMETER['VRDMA']=false;
  fi
}


#---------------------------------------------------------
#
# Calculates amount of actual required ppn to satisfy VM
# resource requirements.
#
calculatePPN() {

  #
  # calculate whether we can satisfy it
  #
  local vcpus=${VM_PARAMETER['VCPUS']};
  local ioCoreMaxCount=${VM_PARAMETER['IOCM_MAX_CORES']};
  local vmsPerNode=${VM_PARAMETER['VMS_PER_NODE']};

  # calculate total amount of cores required per node
  local totalCoresPerNode=$(($HOST_OS_CORE_COUNT + ($vcpus * $vmsPerNode)));

  # ioCM enabled ?
  if ${VM_PARAMETER['IOCM']}; then
    totalCoresPerNode=$(($totalCoresPerNode + $ioCoreMaxCount));
  fi

  # is there a ppn res request ?
  if [[ $PBS_RES_REQ_PPN =~ [0-9]+ ]]; then
    # check if user's ppn request is sufficient to cover the VM resources required
    if [ $PBS_RES_REQ_PPN -lt $totalCoresPerNode ]; then # no, user requested less than needed
     # iocm enabled ?
     if ${VM_PARAMETER['IOCM']}; then
      logInfoMsg "Requested PPN is not sufficient to satisfy VM requirements, \
increasing ppn value to '$totalCoresPerNode'.\n-----\n\
Job needs:\n for host OS '$HOST_OS_CORE_COUNT' cpus\n for IOCM\
 '$ioCoreMaxCount'\n vcpus for each VM '$vcpus' * amount of VMs per node '$vmsPerNode' => '$totalCoresPerNode'\n-----" true;
      # increase ppn value to required count
     else
       logInfoMsg "Requested PPN is not sufficient to satisfy VM requirements, \
increasing ppn value to '$totalCoresPerNode'.\n-----\n\
Job needs:\n for host OS '$HOST_OS_CORE_COUNT' and\n\
 vcpus for each VM '$vcpus' * amount of VMs per node '$vmsPerNode' => '$totalCoresPerNode'\n-----" true;
     fi
      PBS_RES_REQ_PPN=$totalCoresPerNode;
    fi
  fi
}


#---------------------------------------------------------
#
# Calculates the required amount of RAM for the job.
#
calculateRAM() {

  # RAM per VM
  local vRAM=${VM_PARAMETER['RAM']};
  # VMs per node
  local vmsPerNode=${VM_PARAMETER['VMS_PER_NODE']};

  # calculate total RAM required per node
  local totalRAMPerNode=$(($HOST_OS_RAM_MB + ($vRAM * $vmsPerNode)));

  # is there a ppn res request ?
  if [[ $PBS_RES_REQ_RAM =~ ^[0-9]+(mb|gb|tb)$ ]]; then
    # check if user's ppn request is sufficient to cover the VM resources required
    ram=$(_convertRAMtoMB $PBS_RES_REQ_RAM);
    units=$(echo $PBS_RES_REQ_RAM | sed -e 's,^[0-9]+,,g');
    if [ $ram -lt $totalRAMPerNode ]; then # no, user requested less than needed
      logInfoMsg "Requested RAM is not sufficient to satisfy VM requirements, \
increasing RAM value to '$totalRAMPerNode' MB.\n\
Job needs:\n for host OS '$HOST_OS_RAM_MB' MB RAM\n\
 vcpus for each VM '$vRAM' MB RAM * amount of VMs per node '$vmsPerNode' => '$totalRAMPerNode' MB" true;
      # increase ppn value to required count
      PBS_RES_REQ_RAM="${totalRAMPerNode}mb";
    fi
  fi
}


#---------------------------------------------------------
#
# Generate prologue* and epilogue* wrapper scripts for the VM job.
#
generateWrapperScripts() {

  #
  # generate Prologue (VM boot script)
  # and Epilogue (VM tear down script)
  #
  logDebugMsg "Generating user vmPrologue[.parallel] wrappers (vm boot scripts).";

  #
  # copy templates (VM preparation scripts) to their destination
  #

  # ensure destination dirs are in place for the resulting scripts
  mkdir -p $(dirname $SCRIPT_PROLOGUE) 2>/dev/null;

  # copy user prologue template
  cp $SCRIPT_PROLOGUE_TEMPLATE $SCRIPT_PROLOGUE && chmod 700 $SCRIPT_PROLOGUE;
  if [ $? -ne 0 ]; then
    logErrorMsg "Make sure you have write access for dir \
'$(dirname $SCRIPT_PROLOGUE)' and read access for file '$SCRIPT_PROLOGUE_TEMPLATE' !";
  fi

  # copy user prologue.parallel template
  cp $SCRIPT_PROLOGUE_PARALLEL_TEMPLATE $SCRIPT_PROLOGUE_PARALLEL && chmod 700 $SCRIPT_PROLOGUE_PARALLEL;
  if [ ! $? ]; then
    logErrorMsg "Make sure you have write access for dir \
'$(dirname $SCRIPT_PROLOGUE_PARALLEL)' and read access for file '$SCRIPT_PROLOGUE_PARALLEL_TEMPLATE' !";
  fi

  # substitute place-holders in the prologue and epilogue scripts
  logDebugMsg "Replacing place-holders in vmPrologue[.parallel] scripts:";
  logDebugMsg " 1) '$SCRIPT_PROLOGUE'";
  logDebugMsg " 2) '$SCRIPT_PROLOGUE_PARALLEL'";

  # add RUID to list of values to replace
  VM_PARAMETER["RUID"]="$RUID";

  local value;

  # replace all VM parameters
  # (contains parsed args and default values for missing ones)
  for key in "${!VM_PARAMETER[@]}"; do
    value="${VM_PARAMETER[$key]}";
    if [ "$key" == "0" ]; then
      continue;
    else
      placeHolder="__$( echo $key | tr '[:lower:]' '[:upper:]')__";
    fi
    logTraceMsg "Replacing: first match of place-holder '$placeHolder' \
that matches key='$key' with value: '$value'";
    sed -i "0,/$placeHolder/{s,$placeHolder,$value,}" $SCRIPT_PROLOGUE;
    sed -i "0,/$placeHolder/{s,$placeHolder,$value,}" $SCRIPT_PROLOGUE_PARALLEL;
  done

  # set user pro/epilogue scripts
  logTraceMsg "Replacing: all place-holders '__PROLOGUE_SCRIPT__' with '$SCRIPT_PROLOGUE' \
in script '$SCRIPT_PROLOGUE'.";
  sed -i "0,/__PROLOGUE_SCRIPT__/{s,__PROLOGUE_SCRIPT__,$USER_PROLOGUE_SCRIPT,}" $SCRIPT_PROLOGUE;

  # set user VM pro/epilogue scripts
  logTraceMsg "Replacing: all place-holders '__VM_PROLOGUE_SCRIPT__' with '$SCRIPT_PROLOGUE' \
in script '$SCRIPT_PROLOGUE'.";
  sed -i "0,/__VM_PROLOGUE_SCRIPT__/{s,__VM_PROLOGUE_SCRIPT__,$USER_VM_PROLOGUE_SCRIPT,}" $SCRIPT_PROLOGUE;

}


#---------------------------------------------------------
#
# Generate job script wrapper.
#
generateJobScriptWrapper() {

  #
  # generate the job-script wrapper which starts the VM and prepares the
  # environment (+vm contextualization like IP-networking, .. ?)
  #
  logDebugMsg "Generating job script wrapper for vm-based execution.";
  logDebugMsg " 3) '$SCRIPT_PROLOGUE_PARALLEL'";

  # copy template
  mkdir -p $(realpath $(dirname $JOB_SCRIPT_WRAPPER)) 2>/dev/null;
  cp $JOB_SCRIPT_WRAPPER_TEMPLATE $JOB_SCRIPT_WRAPPER;
  # success ?
  if [ ! $? ]; then # no, abort
    logErrorMsg "Make sure you have write access for dir \
'$(dirname $JOB_SCRIPT_WRAPPER)' and read access for file '$JOB_SCRIPT_WRAPPER_TEMPLATE' !";
  fi

  # in case it's a readline job, we need to make the jobWrapper aware of it
  if [ ! -f "$LAST_PARAM" ]; then
    logTraceMsg "Last argument '$LAST_PARAM' is not a file.";
    if $IS_INTERACTIVE_JOB; then
      logTraceMsg "Interactive job detected.";
      # set job type
      JOB_TYPE="@INTERACTIVE_JOB@";
      # there is not job script for interactive jobs
      JOB_SCRIPT="";
      # name the job wrapper as interactive jobs are called
      JOB_WRAPPER_FILENAME=$(realpath $(dirname $JOB_SCRIPT_WRAPPER))/INTERACTIVE;
      # not used in this case, just ensure it doesn't contain anything
      LAST_PARAM="";
      # create indicator flag for x-forwarding request issued by user
      touch "$FLAG_FILE_X11";
    elif $IS_READLINE_JOB; then
      logTraceMsg "STDIN job detected.";
      # set job type
      JOB_TYPE="@STDIN_JOB@";
      # resolve absolute path of the tmp script
      JOB_SCRIPT="$(realpath $TMP_JOB_SCRIPT)";
      # job output prefix (name of output file)
      JOB_WRAPPER_FILENAME=$(realpath $(dirname $JOB_SCRIPT_WRAPPER))/STDIN;
      # not used in this case, just ensure it doesn't contain anything
      LAST_PARAM="";
    else
      logErrorMsg "The job request cannot be identified. \n\
Last parameter is not a valid file '$LAST_PARAM' and it neither seems \
to be an interactive nor a piped job.";
    fi
  else # last parameter is a valid file
    logTraceMsg "Standard batch job detected.";
    # set job type
    JOB_TYPE="@BATCH_JOB@";
    # resolve absolute path
    JOB_SCRIPT="$(realpath $LAST_PARAM)";
    # job output prefix (name of output file)
    JOB_WRAPPER_FILENAME=$(realpath $(dirname $JOB_SCRIPT_WRAPPER))/$(basename $LAST_PARAM);
  fi

  # copy JOB_SCRIPT into job's RUID dir and replace cached one by it
  mkdir -p $VM_JOB_USER_SCRIPT_DIR;
  cp $JOB_SCRIPT $VM_JOB_USER_SCRIPT_DIR/;
  JOB_SCRIPT="$VM_JOB_USER_SCRIPT_DIR/$(basename $JOB_SCRIPT)";
  chmod 700 $JOB_SCRIPT;

  # name the job script the same as the job is named, otherwise the job's
  #  output is called 'jobWrapper.sh.[e|o]\d+'
  logTraceMsg "Renaming copied job script wrapper file '$JOB_SCRIPT_WRAPPER' to '$JOB_WRAPPER_FILENAME'";
  mv $JOB_SCRIPT_WRAPPER $JOB_WRAPPER_FILENAME;
  JOB_SCRIPT_WRAPPER=$JOB_WRAPPER_FILENAME;
  chmod 700 $JOB_SCRIPT_WRAPPER;

  # are there any inline PBS resource requests ?
  if [ -f "$JOB_WRAPPER_RES_REQUEST_FILE" ]; then
    logDebugMsg "Merging detected non-VM '#PBS ..' resource requests,\
\n\tcached in file: '$JOB_WRAPPER_RES_REQUEST_FILE'\ninto job\
script wrapper '$JOB_SCRIPT_WRAPPER'.";
    # replace (first match of) place-holder for '^#PBS ' resource requests
    #  (that do not contain any '-vm ..' args) with file contents
    sed -i "0,/__INLINE_RES_REQUESTS__/{s,__INLINE_RES_REQUESTS__,$(cat $JOB_WRAPPER_RES_REQUEST_FILE),}" $JOB_SCRIPT_WRAPPER;
  else
    logDebugMsg "Nothing to merge, no inline '#PBS' detected (corresponding cache file doesn't exist).";
    sed -i "0,/__INLINE_RES_REQUESTS__/{s,__INLINE_RES_REQUESTS__,#,}"  $JOB_SCRIPT_WRAPPER;
  fi

  # replace (first match of) RUID, vmPro/Epilogues and job-script place holders in the job wrapper
  logTraceMsg "Replacing place-holders in job script wrapper file '$JOB_SCRIPT_WRAPPER'.";
  sed -i "0,/__RUID__/{s,__RUID__,$RUID,}" $JOB_SCRIPT_WRAPPER;
  sed -i "0,/__JOB_SCRIPT__/{s,__JOB_SCRIPT__,$JOB_SCRIPT,}" $JOB_SCRIPT_WRAPPER;
  sed -i "0,/__JOB_TYPE__/{s,__JOB_TYPE__,$JOB_TYPE,}" $JOB_SCRIPT_WRAPPER;
  sed -i "0,/__KEEP_VM_ALIVE__/{s,__KEEP_VM_ALIVE__,${KEEP_VM_ALIVE},}" $JOB_SCRIPT_WRAPPER;
  sed -i "0,/__VCPUS__/{s,__VCPUS__,${VM_PARAMETER['VCPUS']},}" $JOB_SCRIPT_WRAPPER;
  sed -i "0,/__VMS_PER_NODE__/{s,__VMS_PER_NODE__,${VM_PARAMETER['VMS_PER_NODE']},}" $JOB_SCRIPT_WRAPPER;
  sed -i "0,/__DISTRO__/{s,__DISTRO__,${VM_PARAMETER['DISTRO']},}" $JOB_SCRIPT_WRAPPER;
}


#---------------------------------------------------------
#
# Generates all files required to set up and tear down the VMs,
# as well as the job wrapper for the actual execution of the job.
#
generateFiles() {

  # create flag file dir
  mkdir -p "$(dirname $FILESYSTEM_FLAG_FILE)" \
    || logErrorMsg "Failed to create the flag file dir '$FILESYSTEM_FLAG_FILE'.";

  # creating fileystem type file (indicates whether RAMDISK or shared file-sys is to use
  logDebugMsg "Using as file-system type for the job: '${VM_PARAMETER['FILESYSTEM_TYPE']}'";
  echo ${VM_PARAMETER['FILESYSTEM_TYPE']} > $FILESYSTEM_FLAG_FILE;

  # select metadata template (os specific)
  setMetadataTemplate;

  # parse user's metadata if provided (is optional)
  parseUserMetadata;

  # generate the pro/epilogue wrappers, replaces place-holders in templates
  generateWrapperScripts;

  # generate job script wrapper, replaces place-holders in template
  generateJobScriptWrapper;

  #
  # print the resulting file names
  #
  logDebugMsg "----------------Generated_Wrapper_Files_START-----------------------";
  logDebugMsg " Wrapper for user Prologue script:           '$SCRIPT_PROLOGUE'";
  logDebugMsg " Wrapper for user Prologue.parallel script:  '$SCRIPT_PROLOGUE_PARALLEL'";
  logDebugMsg " Wrapper Job script:                         '$JOB_SCRIPT_WRAPPER'";
  logDebugMsg "----------------Generated_Wrapper_Files_END-------------------------";

  # do a simple syntax check
  logDebugMsg "Performing simple syntax check for generated scripts";
  if bash -n $SCRIPT_PROLOGUE \
      && bash -n $SCRIPT_PROLOGUE_PARALLEL \
      && bash -n $JOB_SCRIPT_WRAPPER; then
    logDebugMsg "Generated scripts have passed basic validation checks";
  else
    logErrorMsg "Generated script(s) have syntax errors, templates may be broken!" 3;
  fi

  #
  # construct the actual qsub submission string, depending on the job type
  #
  if [ $JOB_TYPE == "@BATCH_JOB@" ]; then
    # replace the job-script torque knows about with the generated wrapper and add prologue/epilogue
    PARAMETERS_PBS_QSUB="$PARAMETERS_CLEANED -l ${CLEANED_PBS_RES_REQ}prologue=$SCRIPT_PROLOGUE $JOB_SCRIPT_WRAPPER";
  elif [ $JOB_TYPE == "@STDIN_JOB@" ]; then
    # replace the job-script torque knows about with the generated wrapper and add prologue/epilogue
    PARAMETERS_PBS_QSUB="$PARAMETERS_CLEANED -l ${CLEANED_PBS_RES_REQ}prologue=$SCRIPT_PROLOGUE $JOB_SCRIPT_WRAPPER";
  elif [ $JOB_TYPE == "@INTERACTIVE_JOB@" ]; then # interactive job
    # future work
    logErrorMsg "\n*** !!! ***\
We detected that you want to start an interactive VM-based batch job.\n\
Please note, this is future work.\n\
Torque requires a patch for this feature.\n\
*** !!! ***\n";
    # replace the job-script torque knows about with the generated wrapper and add prologue/epilogue
    PARAMETERS_PBS_QSUB="$PARAMETERS_CLEANED -l ${CLEANED_PBS_RES_REQ}prologue=$SCRIPT_PROLOGUE";
  else
    logErrorMsg "Unknown type of job: '$JOB_TYPE'";
  fi

  # replace the PPN to match the min/max IO core count, plus host OS cores, plus vpus * amount of VMs per node
  PARAMETERS_PBS_QSUB=$(echo $PARAMETERS_PBS_QSUB | sed "s,PLACEHOLDER_PPN,$PBS_RES_REQ_PPN,g");
  PARAMETERS_PBS_QSUB=$(echo $PARAMETERS_PBS_QSUB | sed "s,PLACEHOLDER_RAM,$PBS_RES_REQ_RAM,g");
  # remove double '-l'
  PARAMETERS_PBS_QSUB=$(echo $PARAMETERS_PBS_QSUB | sed "s,-l -l,-l,g");

  # exclusive node allocation (and not already set) ?
  if $PBS_EXCLUSIVE_NODE_ALLOC \
      && [ ! -n "$(echo $PARAMETERS_PBS_QSUB | grep naccesspolicy)" ]; then
    PARAMETERS_PBS_QSUB="-l naccesspolicy=uniqueuser $PARAMETERS_PBS_QSUB";
  fi

  # done
  logDebugMsg "Resulting PBS qsub arguments: '$PARAMETERS_PBS_QSUB'";
}


#---------------------------------------------------------
#
# Creates flag files in order to export settings from
# user space to the root scripts.
#
exportFlags() {

  #
  # write out debug/trace flag files used in root scripts
  # that do not have user space env vars available
  #
  if ${VM_PARAMETER['DEBUG']}; then # create flag file
    touch "$FLAG_FILE_DEBUG";
  fi
  if ${VM_PARAMETER['TRACE']}; then # create flag file
    touch "$FLAG_FILE_TRACE";
  fi

  #
  # vRDMA enabled/requested ?
  #
  if ${VM_PARAMETER['VRDMA']}; then
    touch "$FLAG_FILE_VRDMA";
  fi

  #
  # UNCLOT enabled/requested ?
  #
  if ${VM_PARAMETER['UNCLOT']}; then
    touch "$FLAG_FILE_UNCLOT";
  fi

  #
  # iocm enabled/requested ?
  #
  if ${VM_PARAMETER['IOCM']}; then
    echo ${VM_PARAMETER['IOCM_MIN_CORES']} > "$FLAG_FILE_IOCM"; #min cores
    echo ${VM_PARAMETER['IOCM_MAX_CORES']} >> "$FLAG_FILE_IOCM"; #max cores
  fi

  # write out count of VMs per node
  echo "${VM_PARAMETER['VMS_PER_NODE']}" > "$FLAG_FILE_DIR/.vms_per_node";
}


#---------------------------------------------------------
#
# Creates a symlink for the jobID to the RUID dir.
#
createRUID2JOBIDmapping() {

  if [ $# -ne 1 ]; then
    logWarnMsg "No job ID known ?!";
    return 0;
  fi
  local jobID=$1;

  logDebugMsg "Creating sym-link for RUID-2-JOBID mapping: linking dir '$VM_JOB_DIR' \
to '$VM_JOB_DIR_PREFIX/$jobID'";

  #
  # RUID-2-JOBID mapping 
  # (the other part of the logic resides in const.sh where JOBID is used)
  #
  # Job submission was successful, so create a symlink based on the jobID to the RUID dir.
  # This way, the root scripts can write debug msgs to the job's debug log.
  ln -s "$VM_JOB_DIR" "$VM_JOB_DIR_PREFIX/$jobID";
  LOG_FILE="$VM_JOB_DIR_PREFIX/$jobID/debug.log";
}


#---------------------------------------------------------
#
# Determines whether the user wants to have the job debug
# log displayed immediately after job submission.
#
# If $DEBUG is set to false there is no debug log to show
# and nothing to display.
#
# Interactive jobs do not make any sense either, since they
# display everything in the console.
#
showLog() {
  if ! $DO_NOT_SUBMIT_JOB \
      && ! $IS_INTERACTIVE_JOB \
      && [ ! -z ${SHOW_LOG-} ] \
      && $SHOW_LOG; then
    if [ ! -e "$LOG_FILE" ]; then
      touch "$LOG_FILE";
    fi
    trap _printLogFileName SIGHUP SIGINT SIGTERM SIGKILL;
    tail -f -n0 $LOG_FILE;
  fi
}


#---------------------------------------------------------
#
# Abort function that is called by the (global) signal trap.
# Cleans ups the created job dir with generated files.
#
_abort() {

  # inform user
  logInfoMsg "Canceling job submission" true;

  # clean up the created tmp dir
  ! $DEBUG \
    && logInfoMsg "Removing dir '$VM_JOB_DIR/'" true \
    && rm -Rf $VM_JOB_DIR;

  return 0;
}


#---------------------------------------------------------
#
# Alternative sig trap hook, put in place when job is submitted
#
_printLogFileName() {
  echo -e "\nLog file: '$LOG_FILE'";
}



#============================================================================#
#                                                                            #
#                                 MAIN                                       #
#                                                                            #
#============================================================================#

#
# host is disabled for vTorque ?
#
if [ -n "${DISABLED_HOSTS_LIST-}" ] \
    && [[ $LOCALHOST =~ $DISABLED_HOSTS_LIST ]]; then
  echo "vTorque is disabled on this host.";
  exit 1;
fi

# cache RUID in job dir (to enable root epilogue to fetch it)
mkdir -p $(dirname $RUID_CACHE_FILE);
echo $RUID > $RUID_CACHE_FILE;

# debug log
logDebugMsg "********************* BEGIN OF VSUB ************************";

# log the call
logCmdLine "TRACE";

# cached parameters
declare -a PARAMETERS=$@;

# trace logging
logDebugMsg "Arguments received:  '$PARAMETERS'";

#
# check if needed files are present, etc
#
checkPreconditions;

#
# create needed tmp and cache dir(s) for the job
#
prepare;

#
# parse the parameters given in the job script (if there is one)
# and check the type of job request (script, piped, interactive)
# plus fetch the last parameter in case it's a job script
#
parseParameter $PARAMETERS;

# vm job submit detected ?
if ! $VMJOB_REQ_DETECTED; then

  # no, not a VM job
  logDebugMsg "No vm job.";

  # construct submit cmd
  submitCmd="$PBS_QSUB $PARAMETERS";
  logDebugMsg "Submission cmd: '$submitCmd'";

  res="";
  if $IS_BATCH_JOB; then
    jobID=$($submitCmd |& tee -a $LOG_FILE);
    res=$?;
    echo $jobID;
  else #piped and interactive
    logInfoMsg "Interactive job submission requires patched Torque version." true;
    $submitCmd; #no change to fetchthe job ID: patch needed
    res=$?;
  fi

  logTraceMsg "PBS qsub return code: '$res'";

  # create ruid-2-jobId mapping
  if [ $res -ne 0 ] && [ ! -z ${jobID-} ] && [[ $jobID =~ ^[0-9]+$ ]]; then
    createRUID2JOBIDmapping $jobID;
  fi

  # measure time ?
  if $MEASURE_TIME; then
    printRuntime $0 $START;
  fi

  # stop here
  exit $res;
fi
#else: it's a VM job

logInfoMsg "Generating files for VM job, please be patient..";

# ensure flag file dir exists
if [ ! -e "$FLAG_FILE_DIR" ]; then
  mkdir -p "$FLAG_FILE_DIR" \
    || logErrorMsg "Failed to create flag files dir '$FLAG_FILE_DIR'.";
fi
# create indicator flag for VM job
#logDebugMsg "Creating flag file '$FLAG_FILE_DIR/.vmJob'";
touch "$FLAG_FILE_DIR/.vmJob";

#
# apply defaults for not provided, but needed VM parameters
#
applyVMDefaultParameter;

#
# calculate the required cores per node
#
calculatePPN;

#
# calculate the required memory per node
#
calculateRAM;

# generates vmPrologue, Epilogue and jobWrapper scripts
# and detects the job type
# further, replaces the job script and pro/epilogue scripts cached in the var 'parameter' with its wrappers
generateFiles;

# export flags for root scripts
exportFlags;

# generate files, only ?
if $DO_NOT_SUBMIT_JOB; then

  if $PBS_EXCLUSIVE_NODE_ALLOC \
      && [ ! -n "$(echo $PARAMETERS_CLEANED | grep naccesspolicy)" ]; then
    interactiveResReq="-l naccesspolicy=uniqueuser $PARAMETERS_CLEANED";
  else
    interactiveResReq=$PARAMETERS_CLEANED;
  fi

  #yes
  logInfoMsg "User requested to generate files for VM-based execution, only.\
Skippping job submission." true;
  logInfoMsg "=====submit_cmd=====\nqsub $PARAMETERS_PBS_QSUB" true;
  logInfoMsg "====================" true;
  logInfoMsg "1) Get an interactive job with cmd '$PBS_QSUB -I $interactiveResReq'" true;
  logInfoMsg "2) Create missing symlink with cmd: 'ln -s $VM_JOB_DIR $VM_JOB_DIR_PREFIX/\$PBS_JOBID'" true;
  logInfoMsg "3) Re-execute the root-prologue with cmd: 'sudo /var/spool/torque/mom_priv/prologue \$PBS_JOBID $USER'" true;
  logInfoMsg "4) Then run the prologue script '$SCRIPT_PROLOGUE', only." true;
  logInfoMsg "5) And as last run the job script '$JOB_SCRIPT_WRAPPER'." true;
  res=0;

# job script as file or input stream present ?
else

  #
  # submit the job via the real qsub command
  #

  # interative, stdin- or script-based job ?
  if $IS_INTERACTIVE_JOB; then

    # ensure the redirection is not active, otherwise interactive session fails
    stopOutputCapturing;

    # construct submit cmd
    # note, the '-' makes qsub read the input-stream (needed if you wrap 'qsub -I' due to STDIN rading)
    submitCmd="echo 'exec $JOB_SCRIPT_WRAPPER' | $PBS_QSUB $PARAMETERS_PBS_QSUB -;";

  elif $IS_READLINE_JOB; then

    # construct submit cmd
    submitCmd="$PBS_QSUB $PARAMETERS_PBS_QSUB";

  else

    # ensure the job script exists
    if [ ! -n "$JOB_SCRIPT" ] \
       || [ ! -e $JOB_SCRIPT ]; then
      # abort with error
      logErrorMsg "Job script file '$LAST_PARAM' (='$JOB_SCRIPT') \
cannot be loaded - No such file or directory.";
    elif [ -e $JOB_SCRIPT ] \
        && [ ! -f $JOB_SCRIPT ]; then
      # abort with error
      logErrorMsg "Job script '$JOB_SCRIPT' (='$JOB_SCRIPT') is not a file.";
    fi

    # construct submit cmd
    submitCmd="$PBS_QSUB $PARAMETERS_PBS_QSUB";
  fi

  # pass on to PBS qsub
  logDebugMsg "Executing cmd:\n-----\n$submitCmd\n-----";
  logDebugMsg "------PBS_QSUB_START------";

  # execute submission cmd, fetch both stderr and stdout into output
  res="";
  if $DEBUG; then
    jobID=$($submitCmd |& tee -a $LOG_FILE);
  else
    jobID=$($submitCmd);
  fi
  # cache return code
  res=$?;

  # print the job ID
  echo $jobID;
  logDebugMsg "-------PBS_QSUB_END-------";

  # check if there was any error
  if [ $res -ne 0 ]; then
    logErrorMsg "Job Submit failed with return code '$res'.";
  fi
  logTraceMsg "PBS qsub return code: '$res'";
fi

# successful job submission ?
if [ $res -ne 0 ] \
    || [ -z ${jobID-} ] \
    || [[ failed =~ ${jobID-none} ]]; then
  # no, skip it
  jobID="";
  logDebugMsg "No jobID or job submission failed, cannot create RUID-2-JOBID linking.";
else
  # yes, create RUID-2-JOBID mapping (for root pro/epilogue scripts)
  createRUID2JOBIDmapping "$jobID";
fi

# debug log
logDebugMsg "********************* END OF VSUB ************************";

# measure time ?
if $MEASURE_TIME; then
  printRuntime $0 $START;
fi

# show log ?
showLog;

# pass exit code back (not present for interactive jobs - unknown reason)
if [ ! -z ${res-} ]; then
  exit $res;
fi
exit 0;
